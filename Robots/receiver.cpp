/*Това е програмата, която управлява движението на робота. Тя се намира в микроконтролера, който е върху платката на робота. Има RF приемник на 434 MHz, предавател на 315 MHz, драйвер TB6612fng и два 9 волтови електромотора. Приемникът и предавателят задължително трябва да са на различни честоти. Използвам RF приемник от 434 MHz, които да приема данните от дистанционното управление. По този начин роботът получава стойностите на потенциометрите, чрез които се управлява.
Използвам 2 мотора в управлението, един за движение напред и назад и друг за завиване на ляво и на дясно.
Използвам драйвер TB6612fng за управление на моторите. Когато микроконтролерът получи стойностите на потенциометрите, той решава какво трябва да правят моторите - дали да се движат и ако да, в коя посока.
*/
#include <VirtualWire.h>//Този клас е нужен за приемника и предавателя.

int value=0; 
int STBY = 2;
int PWMA = 10; //Speed control 
int AIN1 = 6; //Direction
int AIN2 = 5; //Direction

int PWMB = 7; //Speed control
int BIN1 = 9; //Direction
int BIN2 = 8; //Direction

int a=0,b=0;
int value2=0;

void setup()
{ 
    pinMode(STBY, OUTPUT);
    pinMode(PWMA, OUTPUT);
    pinMode(AIN1, OUTPUT);
    pinMode(AIN2, OUTPUT);
    Serial.begin(9600);	// Debugging only
    // Initialise the IO and ISR
}

void loop()
{
    read();
}
/*
Функцията read чете информацията, получена от приемника. Предавателят е изпратил число и char. Първоначално програмата не знае полученото число на стойността на кой потенциометър съответства. Направил съм така, че предавателят да ги изпраща като променливи. Предавателяt изпраща низ като съобщение и последният знак от низа съответства на променливата в програмата. По този начин програмата разбира получената стойност на кой потенциометър съответства и следователно за кой мотор се отнася.
Именувана е така защото "read" е ключова дума в ардуино.
*/
void read()
{   
    vw_set_ptt_inverted(true); // Required for DR3100
    vw_setup(2000);	 // Bits per sec
    vw_rx_start();       // Start the receiver PLL running
    uint8_t buf[VW_MAX_MESSAGE_LEN]; //Полученото съобщение
    uint8_t buflen = VW_MAX_MESSAGE_LEN; //Дължината на съобщението
    if (vw_get_message(buf, &buflen)) // Non-blocking
    {
        char str[buflen]; /*Тази променлива ще я използвам за да превърна uint8_t в обикновен char масив.*/
	for (int i = 0; i < buflen; i++)
	{
	    str[i]=buf[i]; 
            /*С това условие проверявам дали този елемент в масива е цифра или буква, и ако е да, взема позицията на буквата.*/
            if(buf[i]!=1||buf[i]!=2||buf[i]!=3||
            buf[i]!=4||buf[i]!=5||buf[i]!=6||
            buf[i]!=7||buf[i]!=8||buf[i]!=9)
            value2=i; /*Тази променлива приема позицията на променливата в низа.
            Това е нужно, защото може да се получи греша.
            */
	}
        value = atoi(str); //По този начин преобразувам char в int число.
        //С тези две условия разпознавам променливите, 
        if(str[value2-1]=='a') a=value;
        if(str[value2-1]=='b') b=value;
        
        /*С условията по-долу, програмата проверява стойностите на потенциометрите и при дадената стойност определя в какво положение трябва да са моторите. Деленето на 4 (аз вадя 512 и след това го деля на 2) е нужно, защото потенциометрите имат стойности от 0 до 1024, а драйверът приема от 0 до 255.*/
        if(a>=512) move(1, (a-512)/2, 1); /*Така моторът за движение напред и назад движи роботa напред и намалява, докато се стигне средната стойност на потенциометъра.*/
        else move(1, (512-a)/2, 0); /*Така, колкото повече намалява стойността на потенциометъра, толкова се качва скоростта назад.*/
        
        if(b>462&&b<562) move(0, 0, 1); /*Така моторът за ляво и дясно не работи и роботът се движи напред.*/
        else if(b<=462) move(0, (512-b)/2, 1); //Така се движи на ляво
        else if(b>=562) move(0, (b-512)/2, 0); //Така се движи на дясно   
    }
}

/*Контролът на електромотора, който управлява робота се осъществява от драйвер TB6612FNG, управляван с функцията move. Тя взима 3 входни параметъра. Първи - motor, номерът на мотора който ще се управлява. Втори параметър - speed, с който се контролира скоростта на електромотора, от 0 до 255. Трети параметър - direction, който оказва посоката на въртене на мотора, като стойност 0 означава въртене по посока на часовниковата стрелка, а стойност 1 посока обратна на часовниковата стрелка.
*/
void move(int motor, int speed, int direction){
  digitalWrite(STBY, HIGH); //disable standby
  boolean inPin1 = LOW;
  boolean inPin2 = HIGH;

  if(direction == 1){
    inPin1 = HIGH;
    inPin2 = LOW;
  }

  if(motor == 1){
    digitalWrite(AIN1, inPin1);
    digitalWrite(AIN2, inPin2);
    analogWrite(PWMA, speed);
  }else{
    digitalWrite(BIN1, inPin1);
    digitalWrite(BIN2, inPin2);
    analogWrite(PWMB, speed);
  }
}

//Тази функция изпраща съобщение по предавателя
void send()
{   
    vw_set_ptt_inverted(true); // Required for DR3100
    vw_setup(2000);	 // Bits per sec
    const char *msg = "hello";
    vw_send((uint8_t *)msg, strlen(msg));
    vw_wait_tx(); // Wait until the whole message is gone
}
